#!/usr/bin/env bash

if ! command -v opm-version &> /dev/null; then
PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" || exit; pwd):$PATH"
fi

if ! command -v curl &> /dev/null; then
    opm-println-error "Not found curl command"
    exit 1
fi

if ! command -v jq &> /dev/null; then
    opm-println-error "Not found jq command"
    exit 1
fi

DEFAULT_ADDR="http://localhost:8200"
DEFAULT_MOUNT="secret"
DEFAULT_PATH="default"
DEFAULT_KEYRING_SERVICE="opm-vault"
KEYRING_KEYS=(VAULT_ADDR VAULT_TOKEN VAULT_UNSEAL_KEY)

USAGE="
Usage: opm-vault [options] <command> [key=value ...]

Secret commands:
  set  [k=v ...]    Set a secret (overwrites all keys at path)
  push [k=v ...]    Add/update keys in a secret (keeps existing keys)
  get               Get a secret
  pop  [key ...]    Remove specific keys from a secret
  purge             Remove all data and versions at path
  import            Import secrets from key=value lines (file, stdin, or pipe)

Management commands:
  ls-mount          List mounted secrets engines
  up                Enable KV v2 secrets engine at mount path
  down              Disable secrets engine at mount path

Seal commands:
  seal              Seal the vault
  unseal            Unseal the vault
  seal-state        Get the seal status

Keyring commands:
  set-keys          Save VAULT credentials to keyring
  import-keys       Import VAULT_TOKEN and VAULT_UNSEAL_KEY from init JSON file
  get-keys          Show VAULT credentials from keyring
  del-keys          Remove VAULT credentials from keyring

Available options:
  -h, --help        Print this message
  -j, --json        Pretty print output in JSON format
  -p, --path {path} Secret path (default: '$DEFAULT_PATH')
  -m, --mount {path}
                    KV secrets engine mount path (default: '$DEFAULT_MOUNT')
  -s, --silent      Suppress all messages
  -v, --verbose     Be more verbose during the operation
  --                Stop handling options

Environment variables:
  VAULT_ADDR        Vault server address (default: '$DEFAULT_ADDR')
  VAULT_TOKEN       Vault access token (required for most operations)
  VAULT_UNSEAL_KEY  Vault unseal key (required for unseal)

Examples:
  Set a secret (replaces all keys):
    opm-vault -p my/secret set username=admin password=s3cret

  Add a key to existing secret:
    opm-vault -p my/secret push email=admin@example.com

  Get a secret:
    opm-vault -p my/secret get

  Remove a specific key:
    opm-vault -p my/secret pop username

  Remove all data at path:
    opm-vault -p my/secret purge

  Import from .env file:
    opm-vault -p my/secret import .env

  List mounted secrets engines:
    opm-vault ls-mount

  Unseal the vault:
    opm-vault unseal
"

function print_usage
{
    echo "$USAGE"
}

function resolve_env
{
    local name=$1
    local default_value=${2:-}
    local current_value="${!name:-}"

    if [[ -n "$current_value" ]]; then
        opm-println-debug -v "\$ $name from environment"
        return 0
    fi

    local keyring_value
    keyring_value=$(opm-keys --service "$DEFAULT_KEYRING_SERVICE" get "$name" 2>/dev/null)
    if [[ -n "$keyring_value" ]]; then
        export "$name=$keyring_value"
        opm-println-debug -v "\$ $name from keyring"
        return 0
    fi

    if [[ -n "$default_value" ]]; then
        export "$name=$default_value"
        opm-println-debug -v "\$ $name from default: $default_value"
        return 0
    fi

    opm-println-error "$name is not set."
    return 1
}

function require_vault_addr
{
    resolve_env VAULT_ADDR "$DEFAULT_ADDR"
    VAULT_ADDR="${VAULT_ADDR%/}"
}

function require_vault_token
{
    resolve_env VAULT_TOKEN
}

function require_vault_unseal_key
{
    resolve_env VAULT_UNSEAL_KEY
}

function check_response_errors
{
    local response=$1

    if ! echo "$response" | jq empty 2>/dev/null; then
        opm-println-error "Invalid response (not JSON)"
        return 1
    fi

    if echo "$response" | jq -e 'has("errors")' &>/dev/null; then
        local errors
        errors=$(echo "$response" | jq -r '.errors | .[]' 2>/dev/null)
        if [[ -n "$errors" ]]; then
            opm-println-error "$errors"
        else
            opm-println-error "Request failed (empty error response)"
        fi
        return 1
    fi
}

function opm_vault_set
{
    local json_flag=$1
    local mount=$2
    local path=$3
    shift 3

    require_vault_addr || return $?
    require_vault_token || return $?

    if [[ $# -eq 0 ]]; then
        opm-println-error "At least one key=value pair is required."
        return 1
    fi

    local json_data="{}"
    local kv
    for kv in "$@"; do
        if [[ "$kv" != *"="* ]]; then
            opm-println-error "Invalid key=value format: '$kv'"
            return 1
        fi
        local k="${kv%%=*}"
        local v="${kv#*=}"
        json_data=$(printf '%s' "$json_data" | jq -c --arg k "$k" --arg v "$v" '. + {($k): $v}')
    done

    local api_url="${VAULT_ADDR}/v1/${mount}/data/${path}"
    local payload
    payload=$(jq -cn --argjson data "$json_data" '{"data": $data}')

    opm-println-debug -v "> POST $api_url"
    opm-println-debug -v "> $payload"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --post301 \
        --request POST \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        --header "Content-Type: application/json" \
        --data "$payload"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq
    else
        opm-println "Secret written to: $path"
    fi
}

function opm_vault_push
{
    local json_flag=$1
    local mount=$2
    local path=$3
    shift 3

    require_vault_addr || return $?
    require_vault_token || return $?

    if [[ $# -eq 0 ]]; then
        opm-println-error "At least one key=value pair is required."
        return 1
    fi

    local json_data="{}"
    local kv
    for kv in "$@"; do
        if [[ "$kv" != *"="* ]]; then
            opm-println-error "Invalid key=value format: '$kv'"
            return 1
        fi
        local k="${kv%%=*}"
        local v="${kv#*=}"
        json_data=$(printf '%s' "$json_data" | jq -c --arg k "$k" --arg v "$v" '. + {($k): $v}')
    done

    local api_url="${VAULT_ADDR}/v1/${mount}/data/${path}"
    local payload
    payload=$(jq -cn --argjson data "$json_data" '{"data": $data}')

    opm-println-debug -v "> PATCH $api_url"
    opm-println-debug -v "> $payload"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --request PATCH \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        --header "Content-Type: application/merge-patch+json" \
        --data "$payload"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq
    else
        opm-println "Secret patched to: $path"
    fi
}

function opm_vault_get
{
    local json_flag=$1
    local mount=$2
    local path=$3

    require_vault_addr || return $?
    require_vault_token || return $?

    local api_url="${VAULT_ADDR}/v1/${mount}/data/${path}"

    opm-println-debug -v "> GET $api_url"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --request GET \
        --header "X-Vault-Token: $VAULT_TOKEN"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq '.data.data // {}'
    else
        echo "$response" | jq -r '.data.data // {} | to_entries[] | "\(.key)=\(.value)"'
    fi
}

function opm_vault_pop
{
    local json_flag=$1
    local mount=$2
    local path=$3
    shift 3

    require_vault_addr || return $?
    require_vault_token || return $?

    if [[ $# -eq 0 ]]; then
        opm-println-error "At least one key is required."
        return 1
    fi

    local api_url="${VAULT_ADDR}/v1/${mount}/data/${path}"

    opm-println-debug -v "> GET $api_url"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --request GET \
        --header "X-Vault-Token: $VAULT_TOKEN"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    local existing
    existing=$(echo "$response" | jq -c '.data.data // {}')

    local delete_keys='[]'
    local key
    for key in "$@"; do
        if ! echo "$existing" | jq -e --arg k "$key" 'has($k)' &>/dev/null; then
            opm-println-error "Key not found: $key"
            return 1
        fi
        delete_keys=$(printf '%s' "$delete_keys" | jq -c --arg k "$key" '. + [$k]')
    done

    local new_data
    new_data=$(printf '%s' "$existing" | jq -c --argjson keys "$delete_keys" 'delpaths([$keys[] | [.]])')

    local payload
    payload=$(jq -cn --argjson data "$new_data" '{"data": $data}')

    opm-println-debug -v "> POST $api_url"
    opm-println-debug -v "> $payload"

    local write_response
    write_response=$(
        curl -s \
        --location "$api_url" \
        --post301 \
        --request POST \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        --header "Content-Type: application/json" \
        --data "$payload"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $write_response"
    check_response_errors "$write_response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$write_response" | jq
    else
        opm-println "Keys removed from $path: $*"
    fi
}

function opm_vault_purge
{
    local mount=$1
    local path=$2

    require_vault_addr || return $?
    require_vault_token || return $?

    local api_url="${VAULT_ADDR}/v1/${mount}/metadata/${path}"

    opm-println-debug -v "> DELETE $api_url"

    local http_code
    http_code=$(
        curl -s -o /dev/null -w "%{http_code}" \
        --location "$api_url" \
        --request DELETE \
        --header "X-Vault-Token: $VAULT_TOKEN"
    )

    opm-println-debug -v "< HTTP $http_code"

    if [[ "$http_code" == "204" ]]; then
        opm-println "Secret removed: $path"
    else
        opm-println-error "Failed to remove secret (HTTP $http_code)"
        return 1
    fi
}

function opm_vault_import
{
    local json_flag=$1
    local mount=$2
    local path=$3
    local file=${4:-}

    require_vault_addr || return $?
    require_vault_token || return $?

    local input
    if [[ -n "$file" ]]; then
        if [[ ! -f "$file" ]]; then
            opm-println-error "File not found: $file"
            return 1
        fi
        input=$(< "$file")
    else
        input=$(cat)
    fi

    local payload
    payload=$(printf '%s' "$input" | jq -Rcn '
        [inputs | select(length > 0 and (startswith("#") | not) and contains("=")) |
        index("=") as $i | {(.[:$i]): .[$i+1:]}] | {data: (add // {})}
    ')

    local count
    count=$(printf '%s' "$payload" | jq '.data | length')

    if [[ "$count" -eq 0 ]]; then
        opm-println-error "No key=value pairs found"
        return 1
    fi

    local api_url="${VAULT_ADDR}/v1/${mount}/data/${path}"

    opm-println-debug -v "> POST $api_url"
    opm-println-debug -v "> $payload"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --post301 \
        --request POST \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        --header "Content-Type: application/json" \
        --data "$payload"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq
    else
        opm-println "Secret written to: $path ($count keys)"
    fi
}

function opm_vault_ls_mount
{
    local json_flag=$1

    require_vault_addr || return $?
    require_vault_token || return $?

    local api_url="${VAULT_ADDR}/v1/sys/mounts"

    opm-println-debug -v "> GET $api_url"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --request GET \
        --header "X-Vault-Token: $VAULT_TOKEN"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq
    else
        echo "$response" | jq -r '["PATH","TYPE","DESCRIPTION"], (to_entries[] | select(.value | type == "object" and has("type")) | [.key, .value.type, (.value.description // "")]) | @tsv' | column -t -s $'\t'
    fi
}

function opm_vault_enable
{
    local json_flag=$1
    local mount=$2

    require_vault_addr || return $?
    require_vault_token || return $?

    local api_url="${VAULT_ADDR}/v1/sys/mounts/${mount}"
    local payload='{"type":"kv","options":{"version":"2"}}'

    opm-println-debug -v "> POST $api_url"
    opm-println-debug -v "> $payload"

    local response
    response=$(
        curl -s -w "\n%{http_code}" \
        --location "$api_url" \
        --post301 \
        --request POST \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        --header "Content-Type: application/json" \
        --data "$payload"
    )

    local http_code
    http_code=$(echo "$response" | tail -1)
    response=$(echo "$response" | sed '$d')

    opm-println-debug -v "< HTTP $http_code"
    opm-println-debug -v "< $response"

    if [[ "$http_code" == "204" || "$http_code" == "200" ]]; then
        if [[ $json_flag -ne 0 && -n "$response" ]]; then
            echo "$response" | jq
        else
            opm-println "KV v2 secrets engine enabled at: $mount"
        fi
    else
        check_response_errors "$response" || return $?
        opm-println-error "Failed to enable secrets engine (HTTP $http_code)"
        return 1
    fi
}

function opm_vault_disable
{
    local mount=$1

    require_vault_addr || return $?
    require_vault_token || return $?

    local api_url="${VAULT_ADDR}/v1/sys/mounts/${mount}"

    opm-println-debug -v "> DELETE $api_url"

    local http_code
    http_code=$(
        curl -s -o /dev/null -w "%{http_code}" \
        --location "$api_url" \
        --request DELETE \
        --header "X-Vault-Token: $VAULT_TOKEN"
    )

    opm-println-debug -v "< HTTP $http_code"

    if [[ "$http_code" == "204" ]]; then
        opm-println "Secrets engine disabled at: $mount"
    else
        opm-println-error "Failed to disable secrets engine (HTTP $http_code)"
        return 1
    fi
}

function opm_vault_seal
{
    local json_flag=$1

    require_vault_addr || return $?
    require_vault_token || return $?

    local api_url="${VAULT_ADDR}/v1/sys/seal"

    opm-println-debug -v "> PUT $api_url"

    local http_code
    http_code=$(
        curl -s -o /dev/null -w "%{http_code}" \
        --location "$api_url" \
        --request PUT \
        --header "X-Vault-Token: $VAULT_TOKEN"
    )

    opm-println-debug -v "< HTTP $http_code"

    if [[ "$http_code" == "204" ]]; then
        opm-println "Vault sealed."
    else
        opm-println-error "Failed to seal vault (HTTP $http_code)"
        return 1
    fi
}

function opm_vault_unseal
{
    local json_flag=$1

    require_vault_addr || return $?
    require_vault_unseal_key || return $?

    local api_url="${VAULT_ADDR}/v1/sys/unseal"
    local payload
    payload=$(jq -cn --arg key "$VAULT_UNSEAL_KEY" '{"key": $key}')

    opm-println-debug -v "> PUT $api_url"
    opm-println-debug -v "> $payload"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --request PUT \
        --header "Content-Type: application/json" \
        --data "$payload"
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    local sealed
    sealed=$(echo "$response" | jq -r '.sealed')

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq
    else
        if [[ "$sealed" == "false" ]]; then
            opm-println "Vault unsealed."
        else
            local threshold progress
            threshold=$(echo "$response" | jq -r '.t')
            progress=$(echo "$response" | jq -r '.progress')
            opm-println "Unseal in progress ($progress/$threshold)"
        fi
    fi
}

function opm_vault_seal_state
{
    local json_flag=$1

    require_vault_addr || return $?

    local api_url="${VAULT_ADDR}/v1/sys/seal-status"

    opm-println-debug -v "> GET $api_url"

    local response
    response=$(
        curl -s \
        --location "$api_url" \
        --request GET
    )

    if [[ $? -ne 0 ]]; then
        opm-println-error "Request failed"
        return 1
    fi

    opm-println-debug -v "< $response"
    check_response_errors "$response" || return $?

    if [[ $json_flag -ne 0 ]]; then
        echo "$response" | jq
    else
        local sealed type_val initialized
        sealed=$(echo "$response" | jq -r '.sealed')
        type_val=$(echo "$response" | jq -r '.type')
        initialized=$(echo "$response" | jq -r '.initialized')
        echo "Initialized: $initialized"
        echo "Sealed: $sealed"
        echo "Type: $type_val"
    fi
}

function opm_vault_set_keys
{
    local key
    for key in "${KEYRING_KEYS[@]}"; do
        local current
        current=$(opm-keys --service "$DEFAULT_KEYRING_SERVICE" get "$key" 2>/dev/null)
        local value
        read -r -e -i "$current" -p "$key? " value
        if [[ -n "$value" ]]; then
            opm-keys --service "$DEFAULT_KEYRING_SERVICE" set "$key" "$value"
        fi
    done
}

function opm_vault_import_keys
{
    local file=$1

    if [[ -z "$file" ]]; then
        opm-println-error "Usage: opm-vault import-keys <json-file>"
        return 1
    fi

    if [[ ! -f "$file" ]]; then
        opm-println-error "File not found: $file"
        return 1
    fi

    local token unseal_key
    token=$(jq -r '.root_token // empty' "$file")
    unseal_key=$(jq -r '.keys[0] // empty' "$file")

    if [[ -z "$token" ]]; then
        opm-println-error "root_token not found in $file"
        return 1
    fi
    if [[ -z "$unseal_key" ]]; then
        opm-println-error "keys[0] not found in $file"
        return 1
    fi

    opm-keys --service "$DEFAULT_KEYRING_SERVICE" set VAULT_TOKEN "$token"
    opm-println "VAULT_TOKEN set"

    opm-keys --service "$DEFAULT_KEYRING_SERVICE" set VAULT_UNSEAL_KEY "$unseal_key"
    opm-println "VAULT_UNSEAL_KEY set"
}

function opm_vault_get_keys
{
    local key
    for key in "${KEYRING_KEYS[@]}"; do
        local value
        value=$(opm-keys --service "$DEFAULT_KEYRING_SERVICE" get "$key" 2>/dev/null)
        if [[ -n "$value" ]]; then
            echo "$key=$value"
        else
            echo "$key=(not set)"
        fi
    done
}

function opm_vault_del_keys
{
    local key
    for key in "${KEYRING_KEYS[@]}"; do
        if opm-keys --service "$DEFAULT_KEYRING_SERVICE" rm "$key" 2>/dev/null; then
            opm-println "$key removed"
        fi
    done
}

function opm_vault_main
{
    local json_flag=0
    local silent_flag=0
    local verbose_flag=0
    local mount="$DEFAULT_MOUNT"
    local path="$DEFAULT_PATH"

    while [[ $# -gt 0 ]]; do
        case $1 in
        -h|--help)
            print_usage
            return 0
            ;;
        -j|--json)
            json_flag=1
            shift
            ;;
        -p|--path)
            path="$2"
            shift 2
            ;;
        --path=*)
            path="${1#*=}"
            shift
            ;;
        -s|--silent)
            silent_flag=1
            shift
            ;;
        -v|--verbose)
            verbose_flag=1
            shift
            ;;
        -m|--mount)
            mount="$2"
            shift 2
            ;;
        --mount=*)
            mount="${1#*=}"
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
        esac
    done

    if [[ $verbose_flag -ne 0 ]]; then
        VERBOSE=1
        export VERBOSE
    fi
    if [[ $silent_flag -ne 0 ]]; then
        SILENT=1
        export SILENT
    fi

    if [[ $# -eq 0 ]]; then
        print_usage
        return 0
    fi

    local op=$1
    shift

    case $op in
    set)
        opm_vault_set "$json_flag" "$mount" "$path" "$@"
        ;;
    push)
        opm_vault_push "$json_flag" "$mount" "$path" "$@"
        ;;
    get)
        opm_vault_get "$json_flag" "$mount" "$path"
        ;;
    import)
        opm_vault_import "$json_flag" "$mount" "$path" "$@"
        ;;
    pop)
        opm_vault_pop "$json_flag" "$mount" "$path" "$@"
        ;;
    purge)
        opm_vault_purge "$mount" "$path"
        ;;
    ls-mount|ls-mounts)
        opm_vault_ls_mount "$json_flag"
        ;;
    up|enable)
        opm_vault_enable "$json_flag" "$mount"
        ;;
    down|disable)
        opm_vault_disable "$mount"
        ;;
    seal)
        opm_vault_seal "$json_flag"
        ;;
    unseal)
        opm_vault_unseal "$json_flag"
        ;;
    seal-state|seal-status)
        opm_vault_seal_state "$json_flag"
        ;;
    set-keys)
        opm_vault_set_keys
        ;;
    import-keys)
        opm_vault_import_keys "$@"
        ;;
    get-keys)
        opm_vault_get_keys
        ;;
    del-keys)
        opm_vault_del_keys
        ;;
    *)
        opm-println-error "Unknown command: $op"
        return 1
        ;;
    esac
}

opm_vault_main "$@"
