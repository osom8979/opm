#!/usr/bin/env bash

if ! command -v opm-version &> /dev/null; then
PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" || exit; pwd):$PATH"
fi

DEFAULT_ENV_FILE="$PWD/.env"
DEFAULT_POSTGRES_HOST="localhost"
DEFAULT_POSTGRES_PORT="5432"

USAGE_MESSAGE="
Run SQL scripts against a PostgreSQL database.
Accepts directories (recursively finds *.sql files) and/or individual files.
All collected files are sorted and executed in order.

  Usage: opm-psql-run-scripts [options] <path>...

  <path>  Directory (recursively finds *.sql) or an individual file.
          Multiple paths can be specified.

Connection:
  Uses POSTGRES_URL if set, otherwise builds from individual variables.

Environment variables:
  POSTGRES_URL        Full connection string (takes precedence)
  POSTGRES_HOST       Database host (default: localhost)
  POSTGRES_PORT       Database port (default: 5432)
  POSTGRES_DB         Database name
  POSTGRES_USER       Database user
  POSTGRES_PASSWORD   Database password

Available options are:
  -h, --help             Print this message.
  -e, --env-file=file    Load environment variables from file.
                         Default: \$PWD/.env (if it exists)
  -y, --yes              Skip confirmation prompt.
  -v, --verbose          Print each SQL file name before execution.
  -n, --dry-run          Show which scripts would run without executing.
  --                     Skip handling options.

Examples:
  opm-psql-run-scripts ./migrations
  opm-psql-run-scripts -e .env ./01-tables ./02-functions
  opm-psql-run-scripts -v schema.sql ./seeds
  opm-psql-run-scripts --dry-run ./sql/01-types ./sql/02-tables init.sql
"

function print_usage
{
    echo "$USAGE_MESSAGE"
}

function load_postgres_env
{
    local file=$1
    set -a
    # shellcheck disable=SC1090
    source <(grep -E '^(POSTGRES_)' "$file" | grep -v '^#')
    set +a
}

function opm_psql_run_scripts_main
{
    local verbose=0
    local dry_run=0
    local skip_confirm=0
    local env_file=""
    local env_file_set=0
    local paths=()

    while [[ $# -gt 0 ]]; do
        case $1 in
        -h|--help)
            print_usage
            return 0
            ;;
        -e)
            env_file=$2
            env_file_set=1
            shift 2
            ;;
        --env-file=*)
            env_file=${1#--env-file=}
            env_file_set=1
            shift
            ;;
        -y|--yes)
            skip_confirm=1
            shift
            ;;
        -v|--verbose)
            verbose=1
            shift
            ;;
        -n|--dry-run)
            dry_run=1
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            opm-println-error "Unknown option: $1"
            print_usage
            return 1
            ;;
        *)
            paths+=("$1")
            shift
            ;;
        esac
    done

    # Remaining args after -- are also paths
    while [[ $# -gt 0 ]]; do
        paths+=("$1")
        shift
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        opm-println-error "Missing required argument: <path>..."
        print_usage
        return 1
    fi

    # Load env file: explicit (-e) or default ($PWD/.env)
    if [[ $env_file_set -eq 1 ]]; then
        if [[ ! -f "$env_file" ]]; then
            opm-println-error "Env file not found: $env_file"
            return 1
        fi
        load_postgres_env "$env_file"
    elif [[ -f "$DEFAULT_ENV_FILE" ]]; then
        load_postgres_env "$DEFAULT_ENV_FILE"
    fi

    # Collect SQL files from all paths
    local sql_files=()
    for p in "${paths[@]}"; do
        if [[ -f "$p" ]]; then
            sql_files+=("$(cd "$(dirname "$p")" && pwd)/$(basename "$p")")
        elif [[ -d "$p" ]]; then
            while IFS= read -r -d '' f; do
                sql_files+=("$f")
            done < <(find "$p" -name '*.sql' -print0 | sort -z)
        else
            opm-println-error "Path not found: $p"
            return 1
        fi
    done

    if [[ ${#sql_files[@]} -eq 0 ]]; then
        opm-println-warn "No .sql files found"
        return 0
    fi

    # Build connection string
    local db_url="${POSTGRES_URL:-}"
    if [[ -z "$db_url" ]]; then
        local host=${POSTGRES_HOST:-$DEFAULT_POSTGRES_HOST}
        local port=${POSTGRES_PORT:-$DEFAULT_POSTGRES_PORT}
        local db=${POSTGRES_DB:-}
        local user=${POSTGRES_USER:-}
        local password=${POSTGRES_PASSWORD:-}

        if [[ -z "$db" ]]; then
            opm-println-error "POSTGRES_DB is not set"
            return 1
        fi
        if [[ -z "$user" ]]; then
            opm-println-error "POSTGRES_USER is not set"
            return 1
        fi

        db_url="postgresql://${user}:${password}@${host}:${port}/${db}"
    fi

    # Display target info
    local display_host
    display_host=$(echo "$db_url" | sed 's|.*@||;s|/.*||')

    if ! command -v psql &> /dev/null; then
        opm-println-error "psql is not installed"
        return 1
    fi

    # Show file list and confirm
    opm-println-info "Target: $display_host"
    opm-println-info "Scripts: ${#sql_files[@]} file(s)"
    for f in "${sql_files[@]}"; do
        opm-println "  $f"
    done
    echo ""

    if [[ $skip_confirm -eq 0 ]]; then
        if ! opm-yes-or-no "Proceed?"; then
            opm-println-warn "Aborted"
            return 0
        fi
        echo ""
    fi

    local failed=0
    for f in "${sql_files[@]}"; do
        if [[ $verbose -eq 1 ]]; then
            opm-println-info "Running: $f"
        fi

        if [[ $dry_run -eq 1 ]]; then
            opm-println "[dry-run] psql -f $f"
        elif ! PGDATABASE="$db_url" psql -f "$f" --quiet --set ON_ERROR_STOP=1; then
            opm-println-error "Failed: $f"
            failed=1
            break
        fi
    done

    if [[ $failed -ne 0 ]]; then
        return 1
    fi

    if [[ $verbose -eq 1 ]]; then
        opm-println-info "All scripts executed successfully"
    fi
}

opm_psql_run_scripts_main "$@"
