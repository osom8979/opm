#!/usr/bin/env bash

if ! command -v opm-version &> /dev/null; then
PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" || exit; pwd):$PATH"
fi

DEFAULT_PATTERN="*.sql"

USAGE_MESSAGE="
Run SQL scripts against a PostgreSQL database.
Accepts directories (recursively finds files by pattern) and/or individual files.
All collected files are sorted and executed in order.

  Usage: opm-psql-run-scripts [options] <path>...

  <path>  Directory (recursively finds files by pattern) or an individual file.
          Multiple paths can be specified.

Connection:
  Delegates to opm-psql. See opm-psql --help for connection details.

Available options are:
  -h, --help             Print this message.
  -e, --env-file=file    Load environment variables from file.
                         Default: \$PWD/.env (if it exists)
  --no-env               Skip loading any .env file.
  --show-command         Print the psql command before executing.
  -y, --yes              Skip confirmation prompt.
  -v, --verbose          Print each SQL file name before execution.
  -p, --pattern=glob     File pattern for directory search (default: $DEFAULT_PATTERN).
  -x, --exclude=glob     Exclude files matching glob (repeatable).
  --                     Skip handling options.

Examples:
  opm-psql-run-scripts ./migrations
  opm-psql-run-scripts -e .env ./01-tables ./02-functions
  opm-psql-run-scripts -v schema.sql ./seeds
"

function print_usage
{
    echo "$USAGE_MESSAGE"
}

function opm_psql_run_scripts_main
{
    local verbose=0
    local skip_confirm=0
    local env_file=""
    local env_file_set="auto"
    local show_command=0
    local file_pattern="$DEFAULT_PATTERN"
    local exclude_patterns=()
    local paths=()

    while [[ $# -gt 0 ]]; do
        case $1 in
        -h|--help)
            print_usage
            return 0
            ;;
        -e)
            env_file=$2
            env_file_set="explicit"
            shift 2
            ;;
        --env-file=*)
            env_file=${1#--env-file=}
            env_file_set="explicit"
            shift
            ;;
        --no-env)
            env_file_set="skip"
            shift
            ;;
        --show-command)
            show_command=1
            shift
            ;;
        -y|--yes)
            skip_confirm=1
            shift
            ;;
        -v|--verbose)
            verbose=1
            shift
            ;;
        -p)
            file_pattern=$2
            shift 2
            ;;
        --pattern=*)
            file_pattern=${1#--pattern=}
            shift
            ;;
        -x)
            exclude_patterns+=("$2")
            shift 2
            ;;
        --exclude=*)
            exclude_patterns+=("${1#--exclude=}")
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            opm-println-error "Unknown option: $1"
            print_usage
            return 1
            ;;
        *)
            paths+=("$1")
            shift
            ;;
        esac
    done

    # Remaining args after -- are also paths
    while [[ $# -gt 0 ]]; do
        paths+=("$1")
        shift
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        opm-println-error "Missing required argument: <path>..."
        print_usage
        return 1
    fi

    local opm_psql_args=()
    if [[ $env_file_set == "explicit" ]]; then
        opm_psql_args+=(-e "$env_file")
    elif [[ $env_file_set == "skip" ]]; then
        opm_psql_args+=(--no-env)
    fi
    if [[ $show_command -eq 1 ]]; then
        opm_psql_args+=(--show-command)
    fi

    # Collect SQL files from all paths
    local sql_files=()
    for p in "${paths[@]}"; do
        if [[ -f "$p" ]]; then
            sql_files+=("$(realpath -s "$p")")
        elif [[ -d "$p" ]]; then
            while IFS= read -r -d '' f; do
                sql_files+=("$f")
            done < <(find "$p" -name "$file_pattern" -print0 | sort -z)
        else
            opm-println-error "Path not found: $p"
            return 1
        fi
    done

    # Filter out excluded patterns
    if [[ ${#exclude_patterns[@]} -gt 0 ]]; then
        local filtered=()
        for f in "${sql_files[@]}"; do
            local excluded=0
            local basename=${f##*/}
            for pat in "${exclude_patterns[@]}"; do
                # shellcheck disable=SC2254
                case "$basename" in $pat) excluded=1; break ;; esac
            done
            if [[ $excluded -eq 0 ]]; then
                filtered+=("$f")
            fi
        done
        sql_files=("${filtered[@]}")
    fi

    if [[ ${#sql_files[@]} -eq 0 ]]; then
        opm-println-warn "No files found matching: $file_pattern"
        return 0
    fi

    opm-println "Scripts: ${#sql_files[@]} file(s)"

    # Show file list and confirm
    if [[ $verbose -eq 1 ]]; then
        for f in "${sql_files[@]}"; do
            opm-println "  $f"
        done
    fi
    echo ""

    if [[ $skip_confirm -eq 0 ]]; then
        if ! opm-yes-or-no "Proceed?"; then
            opm-println-warn "Aborted"
            return 0
        fi
        echo ""
    fi

    local failed=0
    for f in "${sql_files[@]}"; do
        if [[ $verbose -eq 1 ]]; then
            opm-println "opm-psql ${opm_psql_args[*]} -- --quiet --set ON_ERROR_STOP=1 -f \"$f\""
        fi

        if ! opm-psql "${opm_psql_args[@]}" -- --quiet --set ON_ERROR_STOP=1 -f "$f"; then
            opm-println-error "Failed: $f"
            failed=1
            break
        fi
    done

    if [[ $failed -ne 0 ]]; then
        return 1
    fi

    if [[ $verbose -eq 1 ]]; then
        opm-println-info "All scripts executed successfully"
    fi
}

opm_psql_run_scripts_main "$@"
