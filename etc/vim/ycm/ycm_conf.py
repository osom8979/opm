#!/usr/bin/env python

import os
import __main__ as main
import ycm_core

SCRIPT_PATH = os.path.abspath(main.__file__)
SCRIPT_DIR = os.path.dirname(SCRIPT_PATH)
WORKING_DIR = os.getcwd()

SOURCE_LOWER_EXTENSIONS = ['.c', '.c++', '.cc', '.cp', '.cpp', '.cxx', '.cu', '.m', '.mm']
SOURCE_UPPER_EXTENSIONS = ['.C', '.C++', '.CC', '.CP', '.CPP', '.CXX', '.CU', '.M', '.MM']
HEADER_LOWER_EXTENSIONS = ['.h', '.h++', '.hh', '.hp', '.hpp', '.hxx', '.cuh', '.inl', '.pch']

SOURCE_EXTENSIONS = list()
SOURCE_EXTENSIONS.append(SOURCE_LOWER_EXTENSIONS)
SOURCE_EXTENSIONS.append(SOURCE_UPPER_EXTENSIONS)

# Set this to the absolute path to the folder (NOT the file!) containing the
# compile_commands.json file to use that instead of 'flags'. See here for
# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
#
# You can get CMake to generate this file for you by adding:
#   set (CMAKE_EXPORT_COMPILE_COMMANDS ON)
# to your CMakeLists.txt file.
#
# Most projects will NOT need to set this to anything; you can just change the
# 'flags' list of compilation flags. Notice that YCM itself uses that approach.
if os.path.isdir(WORKING_DIR):
    COMPILATION_DATABASE = ycm_core.CompilationDatabase(WORKING_DIR)
else:
    COMPILATION_DATABASE = None

DEFAULT_FLAGS = [
        '-Wall',
        '-Wextra',
        '-Werror',
        '-Wno-long-long',
        '-Wno-variadic-macros',
        '-fexceptions',
        #'-DNDEBUG',
        '-std=c++17',
        '-x', 'c++',
        '-isystem', '/usr/include',
        '-isystem', '/usr/local/include',
        '-I.',
        '-I./include',
        '-I./src']
DO_CACHE = True


def isHeaderFile(filename):
    return os.path.splitext(filename)[1].lower() in HEADER_LOWER_EXTENSIONS

def isSourceFile(filename):
    return os.path.splitext(filename)[1].lower() in SOURCE_LOWER_EXTENSIONS

def getCompilationInfoForFile(filename, database):
    """
    The compilation_commands.json file generated by CMake does not have entries
    for header files. So we do our best by asking the db for flags for a
    corresponding source file, if any. If one exists, the flags for that file
    should be good enough.
    """
    if isHeaderFile(filename):
        basename = os.path.splitext(filename)[0]
        for extension in SOURCE_EXTENSIONS:
            replacement_source_file = basename + extension
            if os.path.exists(replacement_source_file):
                compilation_info = database.GetCompilationInfoForFile(replacement_source_file)
                # Bear in mind that compilation_info.compiler_flags_ does NOT return a python list,
                # but a "list-like" StringVec object
                if compilation_info.compiler_flags_:
                    return compilation_info
        return None
    return database.GetCompilationInfoForFile(filename)

def FlagsForFile(filename, **kwargs):
    """
    YCM Entry point
    this function is called by ycmd to produce flags for a file.
    """

    if COMPILATION_DATABASE:
        compilation_info = getCompilationInfoForFile(filename, COMPILATION_DATABASE)
        if not compilation_info:
            return None
        final_flags = list( compilation_info.compiler_flags_ )

        final_flags = MakeRelativePathsInFlagsAbsolute(
            compilation_info.compiler_flags_,
            compilation_info.compiler_working_dir_ )
    else:
        final_flags = DEFAULT_FLAGS

    return {'flags': final_flags,
            'include_paths_relative_to_dir': WORKING_DIR,
            'do_cache': DO_CACHE}

if __name__ == '__main__':
    pass

